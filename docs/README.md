# Task 1
## Description

У нас имеется некий блог со следующими сущностями:

1. Юзер. Имеет только логин.
2. Пост, принадлежит юзеру. Имеет заголовок, содержание, айпи автора (сохраняется отдельно для каждого поста).
3. Оценка, принадлежит посту. Принимает значение от 1 до 5.

Задача: создать JSON API на RoR со следующими экшенами:

1. Создать пост. Принимает заголовок и содержание поста (не могут быть пустыми), а также логин и айпи автора. Если автора с таким логином еще нет, необходимо его создать. Возвращает либо атрибуты поста со статусом 200, либо ошибки валидации со статусом 422.
2. Поставить оценку посту. Принимает айди поста и значение, возвращает новый средний рейтинг поста. Важно: экшен должен корректно отрабатывать при любом количестве конкурентных запросов на оценку одного и того же поста.
3. Получить топ N постов по среднему рейтингу. Просто массив объектов с заголовками и содержанием.
4. Получить список айпи, с которых постило несколько разных авторов. Массив объектов с полями: айпи и массив логинов авторов.

Базу данных используем PostgreSQL. Для девелопмента написать скрипт в db/seeds.rb, который генерирует тестовые данные. Часть постов должна получить оценки. Скрипт должен использовать тот же код, что и контроллеры, можно вообще дергать непосредственно сервер курлом или еще чем-нибудь.

Постов в базе должно быть хотя бы 200к, авторов лучше сделать в районе 100 штук, айпишников использовать штук 50 разных. Экшены должны на стандартном железе работать достаточно быстро как для указанного объема данных (быстрее 100 мс), так и для намного большего, то есть нужен хороший запас в плане оптимизации запросов. Для этого можно использовать денормализацию данных и любые другие средства БД. Можно использовать любые нужные гемы, обязательно наличие спеков, хорошо покрывающих разные кейсы. В коде желательно не использовать рельсовых антипаттернов типа колбеков и валидаций в моделях, сервис-классы наше все. Также желательно не использовать генераторов и вообще обойтись без лишних мусорных файлов в репозитории.

## Result

### API
 - `POST /posts` **params:** `title`, `body`, `user_login`, `author_ip`, **returns:** `{ title, body }`
 - `POST /posts/{post_id}/ratings` **params:** `value`, **returns:** `{ avg_rating }`
 - `GET /top_posts` **params:** `n`, **returns:** array of posts
 - `GET /repeated_ips` **returns:** `[{ ip, logins: [...] }, ...]`

### Notes
 - Запрос `/repeated_ips` максимально по времени не оптимизирован, потому что его оптимизация
   сказывается на скорости вставки данных. Что приоритетнее (этот запрос или вставка данных)
   решает популярность экшенов (и бизнес), и, по логике, `GET /repeated_ips` будет использоваться много реже,
   чем `POST /posts`. Поэтому максимальная оптимизация по времени данного запроса произведена не была.
 - Валидации остались в моделях, потому что их мало и код моделей очень маленький. Поэтому смысла в
   рефакторинге моделей на данном этапе нету.

# Task 2

## Description

Дана таблица users вида - id, group_id

create temp table users(id bigserial, group_id bigint);

insert into users(group_id) values (1), (1), (1), (2), (1), (3);

  1    В этой таблице, упорядоченой по ID необходимо:

  2    выделить непрерывные группы по group_id с учетом указанного порядка записей (их 4)

  3    подсчитать количество записей в каждой группе

  4    вычислить минимальный ID записи в группе

## Result

### Query
```sql
WITH min_groups_ids AS (
  SELECT
    u3.id AS min_id,
    u3.group_id,
    RANK() OVER(ORDER BY u3.id) AS rank
  FROM (
    SELECT
      u.id,
      MIN(u2.id) AS nearest_id,
      u.group_id
    FROM users u
    LEFT JOIN users u2 ON u2.group_id = u.group_id AND u2.id <= u.id
    WHERE u2.id >= u.id - 1
    GROUP BY u.id, u.group_id
    ORDER BY u.id
  ) u3
  WHERE u3.id = u3.nearest_id
), max_groups_ids AS (
  SELECT
    ranked_users.group_id,
    MAX(ranked_users.id) AS max_id,
    ranked_users.rank
  FROM (
    SELECT
      u5.id,
      MAX(min_groups_ids.rank) AS rank,
      u5.group_id
    FROM users u5
    LEFT JOIN min_groups_ids ON min_groups_ids.group_id = u5.group_id AND min_groups_ids.min_id <= u5.id
    GROUP BY u5.id, u5.group_id
    ORDER BY u5.id
  ) ranked_users
  GROUP BY ranked_users.rank, ranked_users.group_id
  ORDER BY ranked_users.rank
)
SELECT
  max_groups_ids.group_id,
  min_groups_ids.min_id,
  max_groups_ids.max_id - min_groups_ids.min_id + 1 AS count
FROM max_groups_ids
INNER JOIN min_groups_ids ON min_groups_ids.rank = max_groups_ids.rank
ORDER BY min_groups_ids.min_id;
```

### Test 1

**Users:**
```
 id | group_id 
----+----------
  1 |        1
  2 |        1
  3 |        1
  4 |        2
  5 |        1
  6 |        3
```

**Result:**
```
 group_id | min_id | count 
----------+--------+-------
        1 |      1 |     3
        2 |      4 |     1
        1 |      5 |     1
        3 |      6 |     1
```

`min_id` - minimal id in the group

`count` - elements count in the group

### Test 2

**Users:**
```
 id | group_id 
----+----------
  1 |        1
  2 |        1
  3 |        1
  4 |        2
  5 |        1
  6 |        3
  7 |        3
  8 |        3
  9 |        1
 10 |        1
 11 |        1
 12 |        1
 13 |        2
 14 |        2
 15 |        1
 16 |        2
 17 |        2
 18 |        2
 19 |        3
 20 |        3
```

**Result:**
```
 group_id | min_id | count 
----------+--------+-------
        1 |      1 |     3
        2 |      4 |     1
        1 |      5 |     1
        3 |      6 |     3
        1 |      9 |     4
        2 |     13 |     2
        1 |     15 |     1
        2 |     16 |     3
        3 |     19 |     2
```
